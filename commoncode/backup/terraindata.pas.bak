unit TerrainData;

interface

uses SysUtils, Collect, TerServerCommon, terrainparams,
     CastleVectors, CastleTerrain, watergrid;

type TTerTile = class; { forward }

     TTileList = class( tsortedCollection )

        function tilexy( x, y : integer ) : TTerTile;
        function findtile( x, y : integer;
                           var ix : integer ) : boolean;
        function initxy( x, y : integer;
                         tilesz : integer ) : TTerTile;
        function getinittile( const tileinfo : TTileHeader ) : TTerTile;


        function keyof( item : pointer ) : pointer; override;
        function compare( item1, item2 : pointer ) : integer; override;

      end;

     TDataLayer = class
        DataGrid : TBaseDataGrid;
        procedure initgrid( igridsz : dword ); virtual;
        function gridsz : dword;
      end;

     TDataLayers = array of TDataLayer;

     TTerTile = class

        Info        : TTileHeader;

        constructor create( const iInfo : TTileHeader );
        destructor destroy; override;

        function getWorldSize : single;
        function gridStep : single;

        public
        {$ifdef terserver}
        datalayers : TDataLayers;
        procedure UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );

        private
        function getTerrainGrid : TSingleGrid;
        public
        property TerrainGrid : TSingleGrid read getTerrainGrid;
        {$else}
        Graphics : pointer;
        {$endif}
      end;

procedure sethxy( var h : TTileHeader; x, y : smallint; sz : word = 1 );

const GTileList : TTileList = nil;

implementation

procedure sethxy( var h : TTileHeader; x, y : smallint; sz : word = 1 ); inline;
 begin
   with h do
    begin
      tilex := x;
      tiley := y;
      tilesz := sz;
    end;
 end;

function compareint( v1, v2 : integer ) : integer; inline;
 begin
   result := -ord( v1 < v2 ) + ord( v1 > v2 );
 end;

//----------------------------------

function TTileList.keyof( item : pointer ) : pointer;
 begin
   result := @TTerTile( item ).Info;
 end;

function TTileList.compare( item1, item2 : pointer ) : integer;
 var h1, h2 : TTileHeader;
     result2 : integer;
 begin
   h1 := PTileHeader( item1 )^;
   h2 := PTileHeader( item2 )^;
   result2 := compareint( h1.TileY, h2.TileY );
   if result2 = 0 then
      result2 := compareint( h1.TileX, h2.TileX );
 end;

function TTileList.findtile( x, y : integer;
                             var ix : integer ) : boolean;
 var h : ttileheader;
 begin
   sethxy( h, x, y );
   result := search( @h, ix );
 end;

function TTileList.tilexy( x, y : integer ) : TTerTile;
 var i : integer;
 begin
   result := nil;
   if findtile( x, y, i ) then
      result := TTerTile( at( i ));
 end;

function TTileList.initxy( x, y : integer;
                           tilesz : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   if findtile( x, y, i ) then
    begin
      result := TTerTile( at( i ));
      result.Info.TileSz := tilesz;
    end
   else
    begin
      sethxy( h, x, y );
      h.TileSz := tilesz;
      result := TTerTile.create( h );
      atinsert( i, result );
    end;
 end;

function TTileList.getinittile( const tileinfo : TTileHeader ) : TTerTile;
 var i : integer;
 begin
   if search( @tileinfo, i ) then
    begin
      result := TTerTile( at( i ));
      result.Info := tileinfo;
    end
   else
    begin
      result := TTerTile.create( tileinfo );
      atinsert( i, result );
    end;
 end;

//-------------------------------

procedure TDataLayer.initgrid( igridsz : dword );
 begin
   DataGrid := tsinglegrid.create( 0, igridsz );
 end;

function TDataLayer.gridsz : dword;
 begin
   assert( assigned( datagrid ));
   result := datagrid.w;
 end;

//-------------------------------
constructor TTerTile.create( const iInfo : TTileHeader );
 var layer : TDataLayer;
 begin
   Info := iInfo;
   {$ifdef terserver}
   SetLength( datalayers, 1 );
   layer := TDataLayer.create;
   layer.initgrid( Info.TileSz );
   datalayers[0] := layer;
   {$else}
   Graphics := nil;
   {$endif}
 end;

destructor TTerTile.destroy;
 {$ifdef terserver}var i : integer;{$endif}
 begin
   inherited;
   {$ifdef terserver}
   for i := 0 to length( datalayers ) - 1 do
      datalayers[i].Free;
   setlength( datalayers, 0 );
   {$endif}
 end;

function TTerTile.gridStep : single;
 var loddiv : integer;
 begin
   loddiv := GDefGridCellCount div Info.TileSz;
   result := GDefGridStep * loddiv;
 end;

function TTerTile.getWorldSize : single;
 begin
   result := GDefGridCellCount * GDefGridStep;
 end;

{$ifdef terserver}
function TTerTile.getTerrainGrid : TSingleGrid;
 begin
   Result := TSingleGrid( datalayers[0].DataGrid );
 end;

procedure TTerTile.UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );
 var y, x, factor : dword;
     step, sz2 : single;
     pos : TVector2;
     h0 : single;
     Grid : TSingleGrid;
     QueryOffset : TVector2;
     tilesize : single;
 begin
   assert( assigned( source ));
   sz2 := getWorldSize * 0.5;
   factor := GDefGridCellCount div Info.TileSz;
   tilesize := getWorldSize;
   QueryOffset := Vector2( Info.TileX * tilesize, Info.TileY * tilesize);
   pos := Vector2( queryoffset.x-sz2, queryoffset.y-sz2 );
   step := GridStep * factor;
   Grid := TerrainGrid;

   for y := 0 to Grid.h - 1 do
    begin
      for x := 0 to Grid.w - 1 do
       begin
         h0 := Source.Height( pos, pos );
         Grid.SetValuexy( x, y, h0 );
         pos.x := pos.x + step;
       end;
      pos := vector2( queryoffset.x-sz2, pos.y + step );
    end;
end;
{$endif}

initialization
  GTileList := TTileList.create;
finalization
  GTileList.Free;
end.
