unit TerrainData;

interface

uses Classes, SysUtils, Collect, TerServerCommon, terrainparams,
     CastleVectors, CastleTerrain, watergrid,
     math, castletransform,
     debug;

const terrainpath = 'data\terrain\';
      terrainext  = '.ter';
      rootpath = 'e:\terrainserver\';

type TTerTile = class; { forward }

     TTileList = class( tsortedCollection )

        function tilexy( x, y : integer ) : TTerTile;
        function findtile( x, y : integer;
                           var ix : integer ) : boolean;
        function initxy( x, y : integer;
                         tilesz : integer ) : TTerTile;
        function getinittile( const tileinfo : TTileHeader ) : TTerTile;


        function keyof( item : pointer ) : pointer; override;
        function compare( item1, item2 : pointer ) : integer; override;

        function getneighbor( tile : TTerTile;
                              dx, dy : integer ) : TTerTile;

        function CalculateTileOffset( Pos : TVector2 ) : TPoint;

        function findtileatlocation( const Pos : TVector2;
                                     var tile : TTerTile ) : boolean;

      end;

     TDataLayer = class
        DataGrid : TBaseDataGrid;
        procedure initgrid( igridsz : dword ); dynamic;
        function gridsz : dword;
      end;

     TIntLayer = class( TDataLayer )
        procedure initgrid( igridsz : dword ); override;
      end;

     TDataLayers = array of TDataLayer;

     TTerTile = class

        Info   : TTileHeader;
        {$ifdef terserver}
        Status : TTileStatus;
        {$endif}

        constructor create( const iInfo : TTileHeader );
        destructor destroy; override;

        function getWorldSize : single;
        function gridStep : single;
        function tileid : string;

        public
        {$ifdef terserver}
        datalayers : TDataLayers;
        procedure UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );

        function SaveToFile : boolean;
        function LoadFromFile : boolean;

        private
        function getTerrainGrid : TSingleGrid;
        public
        property TerrainGrid : TSingleGrid read getTerrainGrid;
        {$else}
        Graphics : TCastleTransform;
        {$endif}
      end;

procedure sethxy( var h : TTileHeader; x, y : smallint; sz : word = 1 );

const GTileList : TTileList = nil;

implementation

procedure sethxy( var h : TTileHeader; x, y : smallint; sz : word = 1 ); inline;
 begin
   with h do
    begin
      tilex := x;
      tiley := y;
      tilesz := sz;
    end;
 end;

function compareint( v1, v2 : integer ) : integer; inline;
 begin
   result := -ord( v1 < v2 ) + ord( v1 > v2 );
 end;

//----------------------------------

function TTileList.keyof( item : pointer ) : pointer;
 begin
   result := @TTerTile( item ).Info;
 end;

function TTileList.compare( item1, item2 : pointer ) : integer;
 var h1, h2 : TTileHeader;
 begin
   h1 := PTileHeader( item1 )^;
   h2 := PTileHeader( item2 )^;
   result := compareint( h1.TileY, h2.TileY );
   if result = 0 then
      result := compareint( h1.TileX, h2.TileX );
 end;

function TTileList.findtile( x, y : integer;
                             var ix : integer ) : boolean;
 var h : ttileheader;
 begin
   sethxy( h, x, y );
   result := search( @h, ix );
 end;

function TTileList.tilexy( x, y : integer ) : TTerTile;
 var i : integer;
 begin
   result := nil;
   if findtile( x, y, i ) then
      result := TTerTile( at( i ));
 end;

function TTileList.initxy( x, y : integer;
                           tilesz : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   if findtile( x, y, i ) then
    begin
      result := TTerTile( at( i ));
      result.Info.TileSz := tilesz;
    end
   else
    begin
      sethxy( h, x, y, tilesz );
      result := TTerTile.create( h );
      atinsert( i, result );
    end;
 end;

function TTileList.getinittile( const tileinfo : TTileHeader ) : TTerTile;
 var i : integer;
 begin
   if search( @tileinfo, i ) then
    begin
      result := TTerTile( at( i ));
      result.Info := tileinfo;
    end
   else
    begin
      result := TTerTile.create( tileinfo );
      atinsert( i, result );
    end;
 end;

function TTileList.getneighbor( tile : TTerTile;
                                dx, dy : integer ) : TTerTile;
 var ix : integer;
     x, y : integer;
 begin
   result := nil;
   x := tile.Info.TileX + dx;
   y := tile.Info.TileY + dy;
   if findtile( x, y, ix ) then
      result := TTerTile( at( ix ));
 end;

function TTileList.CalculateTileOffset( Pos : TVector2 ) : TPoint;
 var sizefactor : single;
     tilesz : single;
 begin
   tilesz := GDefGridCellCount * GDefGridStep;
   sizefactor := 1/tilesz;
   Result := Point( floor( Pos.X * SizeFactor + 0.5 ),
                    floor( Pos.Y * SizeFactor + 0.5 ));
 end;

function TTileList.findtileatlocation( const Pos : TVector2;
                                        var tile : TTerTile ) : boolean;
 var pt : TPoint;
 begin
   tile := nil;
   pt := CalculateTileOffset( Pos );
   tile := tilexy( pt.x, pt.y );
   result := assigned( tile );
 end;

//-------------------------------

procedure TDataLayer.initgrid( igridsz : dword );
 begin
   DataGrid := tsinglegrid.create( 0, igridsz );
 end;

function TDataLayer.gridsz : dword;
 begin
   assert( assigned( datagrid ));
   result := datagrid.wh;
 end;

//-------------------------------

procedure TIntLayer.initgrid( igridsz : dword );
 begin
   DataGrid := tintgrid.create( 0, igridsz );

 end;

//-------------------------------
constructor TTerTile.create( const iInfo : TTileHeader );
 var layer : TDataLayer;
 begin
   Info := iInfo;
   {$ifdef terserver}
   SetLength( datalayers, 2 );
   { intialize terrain layer }
   layer := TDataLayer.create;
   layer.initgrid( Info.TileSz );
   datalayers[0] := layer;
   { initialize splat layer }
   layer := TIntLayer.create;
   layer.initgrid( Info.TizeSz );
   datalayers[1] := layer;

   status := 0;
   {$else}
   Graphics := nil;
   {$endif}
 end;

destructor TTerTile.destroy;
 {$ifdef terserver}var i : integer;{$endif}
 begin
   inherited;
   {$ifdef terserver}
   for i := 0 to length( datalayers ) - 1 do
      datalayers[i].Free;
   setlength( datalayers, 0 );
   {$endif}
 end;

function zeropad( value : integer; len : integer  = 2 ) : string;
 begin
   result := Inttostr( value );
   if length( result ) < len then
      insert( '0', result, 0 );
 end;

function TTerTile.tileid : string;
 var token1, token2 : string;
 begin
   if info.TileX < 0 then
      token1 := 'W'+zeropad( abs( info.Tilex ))
   else
      token1 := 'E'+zeropad( info.tilex );
   if info.TileY < 0 then
      token2 := 'S'+zeropad( abs( info.Tiley ))
   else
      token2 := 'N'+zeropad( info.tiley );
   result := token1+token2;
 end;

function TTerTile.gridStep : single;
 var loddiv : integer;
 begin
   loddiv := GDefGridCellCount div ( Info.TileSz{$ifndef terserver}-1{$endif} );
   result := GDefGridStep * loddiv;
 end;

function TTerTile.getWorldSize : single;
 begin
   result := GDefGridCellCount * GDefGridStep;
 end;

{$ifdef terserver}
function TTerTile.getTerrainGrid : TSingleGrid;
 begin
   Result := TSingleGrid( datalayers[0].DataGrid );
 end;

procedure TTerTile.UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );
 var y, x, factor : dword;
     step, sz2 : single;
     pos : TVector2;
     h0 : single;
     Grid : TSingleGrid;
     QueryOffset : TVector2;
     tilesize : single;
 begin
   assert( assigned( source ));
   sz2 := getWorldSize * 0.5;
   factor := GDefGridCellCount div Info.TileSz;
   tilesize := getWorldSize;
   QueryOffset := Vector2( Info.TileX * tilesize, Info.TileY * tilesize);
   pos := Vector2( queryoffset.x-sz2, queryoffset.y-sz2 );
   step := GridStep * factor;
   Grid := TerrainGrid;

   for y := 0 to Grid.wh - 1 do
    begin
      for x := 0 to Grid.wh - 1 do
       begin
         h0 := Source.Height( pos, pos );
         Grid.SetValuexy( x, y, h0 );
         pos.x := pos.x + step;
       end;
      pos := vector2( queryoffset.x-sz2, pos.y + step );
    end;
   status := status or tile_built or tile_dirty;
end;

function TTerTile.SaveToFile : boolean;
 var filename : string;
     stream : TStream;
     datagrid : TSingleGrid;
     dirty : boolean;
 begin
   filename := rootpath + terrainpath + tileid + terrainext;
   dirty := ( status and tile_dirty > 0 );
   if dirty or not fileexists( filename ) then
    begin
      datagrid := getTerrainGrid;
      stream := TFileStream.Create(filename, fmCreate );
      stream.Write( datagrid.Data^, datagrid.datasz);
      stream.Free;
      dbgwrite( 'Saved '+tileid+'.  ' );
      if dirty then
         status := status xor tile_dirty;
    end;
   result := true;
 end;

function TTerTile.LoadfromFile : boolean;
 var filename : string;
     stream : TStream;
     datagrid : TSingleGrid;
 begin
   filename := rootpath + terrainpath + tileid + terrainext;
   result := fileexists( filename );
   if result then
    begin
      datagrid := getTerrainGrid;
      stream := TFileStream.Create(filename, fmOpenRead);
      stream.Read( datagrid.Data^, datagrid.datasz);
      stream.Free;
      if status and tile_dirty > 0 then
         status := status xor tile_dirty;
    end;
 end;

{$endif}

initialization
  GTileList := TTileList.create;
finalization
  GTileList.Free;
end.
