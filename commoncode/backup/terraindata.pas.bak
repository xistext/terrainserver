unit TerrainData;

interface

uses SysUtils, Collect, TerServerCommon, terrainparams,
     CastleVectors, CastleTerrain, watergrid;

type TTerTile = class; { forward }

     TTileList = class( tsortedCollection )
        function keyof( item : pointer ) : pointer; override;
        function compare( item1, item2 : pointer ) : integer; override;
        function createtile( const iInfo : TTileHeader ) : TTerTile; virtual;
        function tilexy( x, y : integer ) : TTerTile;
        function initxy( x, y : integer;
                         tilesz : integer ) : TTerTile;
        function getinittile( const tileinfo : TTileHeader ) : TTerTile;
      end;

     TDataLayer = class
        DataGrid : TBaseDataGrid;
        procedure initgrid( igridsz : dword ); virtual;
        function gridsz : dword;
      end;

     TDataLayers = array of TDataLayer;

     TTerTile = class

        Info        : TTileHeader;

        constructor create( const iInfo : TTileHeader );
        destructor destroy; override;

        function getWorldSize : single;
        function gridStep : single;

        public
        {$ifdef terserver}
        QueryOffset : TVector2;
        Dirty       : boolean;
        datalayers : TDataLayers;
        procedure UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );

        private
        function getTerrainGrid : TSingleGrid;
        public
        property TerrainGrid : TSingleGrid read getTerrainGrid;
        {$else}
        Graphics : pointer;
        {$endif}
      end;


const GTileList : TTileList = nil;

implementation

procedure sethxy( var h : TTileHeader; x, y : smallint ); inline;
 begin
   with h do
    begin
      tilex := x;
      tiley := y;
    end;
 end;

function compareint( v1, v2 : integer ) : integer; inline;
 begin
   result := -ord( v1 < v2 ) + ord( v1 > v2 );
 end;

//----------------------------------

function TTileList.keyof( item : pointer ) : pointer;
 begin
   result := @TTerTile( item ).Info;
 end;

function TTileList.compare( item1, item2 : pointer ) : integer;
 var h1, h2 : TTileHeader;
     result2 : integer;
 begin
   h1 := PTileHeader( item1 )^;
   h2 := PTileHeader( item2 )^;
   result2 := compareint( h1.TileY, h2.TileY );
   if result2 = 0 then
      result2 := compareint( h1.TileX, h2.TileX );
 end;

function TTileList.tilexy( x, y : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   sethxy( h, x, y );
   if search( @h, i ) then
      result := TTerTile( at( i ));
 end;

function TTileList.initxy( x, y : integer;
                           tilesz : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   sethxy( h, x, y );
   if search( @h, i ) then
    begin
      result := TTerTile( at( i ));
      result.Info.TileSz := tilesz;
    end
   else
    begin
      h.TileSz := tilesz;
      result := createtile( h );
      atinsert( i, result );
    end;
 end;

function TTileList.getinittile( const tileinfo : TTileHeader ) : TTerTile;
   var i : integer;
   begin
     if search( @tileinfo, i ) then
      begin
        result := TTerTile( at( i ));
        result.Info := tileinfo;
      end
     else
      begin
        result := createtile( tileinfo );
        atinsert( i, result );
      end;
   end;

function TTileList.createtile( const iInfo : TTileHeader ) : TTerTile;
 begin
   result := TTerTile.Create( iInfo );
 end;

//-------------------------------

procedure TDataLayer.initgrid( igridsz : dword );
 begin
   DataGrid := tsinglegrid.create( 0, igridsz );
 end;

function TDataLayer.gridsz : dword;
 begin
   assert( assigned( datagrid ));
   result := datagrid.w;
 end;

//-------------------------------
constructor TTerTile.create( const iInfo : TTileHeader );
 var TileSize : single;
     layer : TDataLayer;
 begin
   Info := iInfo;
   {$ifdef terserver}
   Dirty := true;
   SetLength( datalayers, 1 );
   layer := TDataLayer.create;
   layer.initgrid( Info.TileSz );
   datalayers[0] := layer;
   TileSize := getWorldSize;
   QueryOffset := Vector2( Info.TileX * TileSize, Info.TileY * TileSize );
   {$else}
   Graphics := nil;
   {$endif}
 end;

destructor TTerTile.destroy;
 {$ifdef terserver}var i : integer;{$endif}
 begin
   {$ifdef terserver}
   for i := 0 to length( datalayers ) - 1 do
      datalayers[i].Free;
   setlength( datalayers, 0 );
   {$endif}
 end;

function TTerTile.gridStep : single;
 var loddiv : integer;
 begin
   loddiv := GDefGridCellCount div Info.TileSz;
   result := GDefGridStep * loddiv;
 end;

function TTerTile.getWorldSize : single;
 begin
   result := GDefGridCellCount * GDefGridStep;
 end;

{$ifdef terserver}
function TTerTile.getTerrainGrid : TSingleGrid;
 begin
   Result := TSingleGrid( datalayers[0].DataGrid );
 end;

procedure TTerTile.UpdateTerrainGridFromSource( Source : TCastleTerrainNoise );
 var y, x, factor : dword;
     step, sz2 : single;
     pos : TVector2;
     h0 : single;
     Grid : TSingleGrid;
 begin
   assert( assigned( source ));
   sz2 := getWorldSize * 0.5;
   factor := GDefGridCellCount div Info.TileSz;
   pos := Vector2( queryoffset.x-sz2, queryoffset.y-sz2 );
   step := GridStep * factor;
   Grid := TerrainGrid;

   for y := 0 to Grid.h - 1 do
    begin
      for x := 0 to Grid.w - 1 do
       begin
         h0 := Source.Height( pos, pos );
         Grid.SetValuexy( x, y, h0 );
         pos.x := pos.x + step;
       end;
      pos := vector2( queryoffset.x-sz2, pos.y + step );
    end;
   dirty := false;
 end;
{$endif}

initialization
  GTileList := TTileList.create;
finalization
  GTileList.Free;
end.
