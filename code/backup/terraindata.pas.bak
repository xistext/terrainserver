unit TerrainData;

interface

uses Collect, TServerCommon, terrainparams,
     CastleVectors, CastleTerrain, watergrid;

type TTerTile = class; { forward }

     TTileList = class( tsortedCollection )
        function keyof( item : pointer ) : pointer; override;
        function compare( item1, item2 : pointer ) : integer; override;
        function tilexy( x, y : integer ) : TTerTile;
        function initxy( x, y : integer ) : TTerTile;
      end;

     TTerTile = class

        Info : TTileHeader;
        SourceData : TCastleTerrainNoise;
        TerrainGrid : TSingleGrid;

        fGridCount : integer;
        fGridStep  : single;
        QueryOffset : TVector2;

        constructor create( const iInfo : TTileHeader );
        destructor destroy; override;

        function getSize : single;

        procedure UpdateTerrainGridFromSource;

      end;


const GTileList : TTileList = nil;
      GTileSize : integer = 100;

implementation

procedure TTerData.DataModified;
 begin


 end;

//-------------------------------

function TTileList.keyof( item : pointer ) : pointer;
 begin
   result := @TTerTile( item ).Info;
 end;

function TTileList.compare( item1, item2 : pointer ) : integer;
 var h1, h2 : TTileHeader;
 begin
   result := 0;
   h1 := PTileHeader( item1 )^;
   h2 := PTileHeader( item2 )^;
   if h1.TileY < h2.TileY then
      result := -1
   else
   if h1.TileY > h2.TileY then
      result := 1
   else
   if h1.TileX < h2.TileX then
      result := -1
   else
   if h1.TileX > h2.TileX then
      result := 1;
 end;

function TTileList.tilexy( x, y : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   h.TileX := x;
   h.TileY := y;
   if search( @h, i ) then
      result := TTerTile( at( i ));
 end;

function TTileLIst.initxy( x, y : integer ) : TTerTile;
 var h : TTileHeader;
     i : integer;
 begin
   result := nil;
   h.TileX := x;
   h.TileY := y;
   if search( @h, i ) then
      result := TTerTile( at( i ))
   else
    begin
      h.TileW := GTileSize;
      h.TileH := GTileSize;
      result := TTerTile.create( h );
      atinsert( i, result );
    end;
 end;

//-------------------------------
constructor TTerTile.create( const iInfo : TTileHeader );
 var TileSize : single;
 begin
   Info := iInfo;
   SourceData := nil;
   TerrainGrid := tsinglegrid.create;
   fGridCount := GDefGridCellCount;
   fGridStep  := GDefGridStep;
   TileSize := getSize;
   QueryOffset := Vector2( Info.TileX * TileSize, Info.TileY * TileSize );
 end;

destructor TTerTile.destroy;
 begin
   if assigned( sourcedata ) then
      sourcedata.free;
   TerrainGrid.Free;
 end;

function TTerTile.getSize : single;
 begin
   result := ( fGridCount {- 1} ) * fGridStep;
 end;

procedure TTerTile.UpdateTerrainGridFromSource;
 var y, x : dword;
     factor, step, sz2 : single;
     pos : TVector2;
     h0 : single;
 begin
   if not assigned( sourcedata ) then
      exit;
   sz2 := getSize * 0.5;
   factor := 1;
   pos := Vector2( queryoffset.x-sz2, queryoffset.y-sz2 );
   step := fGridStep * factor;

   for y := 0 to TerrainGrid.h - 1 do
    begin
      for x := 0 to TerrainGrid.w - 1 do
       begin
         h0 := SourceData.Height( pos, pos );
         TerrainGrid.SetValuexy( x, y, h0 );
         pos.x := pos.x + step;
       end;
      pos := vector2( queryoffset.x-sz2, pos.y + step );
    end;

 end;

initialization
  GTileList := TTileList.create;
finalization
  GTileList.Free;
end.
